program cut_sphere
   implicit real*8(a-h,o-z)
   integer, parameter :: maxatom=10000
   character(len=2)   :: at(maxatom),atfin(maxatom),atmm(maxatom)
   real*8    :: x(maxatom), y(maxatom), z(maxatom)
   real*8    :: xfin(maxatom),yfin(maxatom),zfin(maxatom)
   real*8    :: xmm(maxatom),ymm(maxatom),zmm(maxatom)
   real*8    :: rmin(maxatom),r(maxatom,maxatom), rmolmin(maxatom)
   integer   :: index(maxatom),index_rev(maxatom)
   integer   :: natmol=3, nmol=-1, nsolute=-1, atidx=-1
   real*8    :: rad=-1
   logical   :: lcom=.false.


! TODO:  base it also on radius rather than nmol

   call Get_cmdline(natmol, nmol, nsolute, rad, lcom, atidx)

   read(*,*)natom
   write(*,*)'Total number of atoms:', natom
   if(natom.gt.maxatom)then
      write(*,*)'ERROR: number of atoms is greater than maximum.'
      write(*,*)'Adjust parameter maxatom and recompile'
      stop 1
   end if

   read(*,*)
   do i=1,natom
      read(*,*)at(i),x(i),y(i),z(i)
   enddo

   if (lcom)then
      xt=0.0
      yt=0.0
      zt=0.0
      do i=1,nsolute
         xt=xt+x(i)
         yt=yt+y(i)
         zt=zt+z(i)
      enddo
      xt=xt/nsolute
      yt=yt/nsolute
      zt=zt/nsolute
   end if

   if(atidx.gt.0)then
      xt=x(atidx)
      yt=y(atidx)
      zt=z(atidx)
   end if
 

! determine the closest distance of the solvent atoms to solute
! based on all atoms in the solute
   do i=nsolute+1,natom
      rmin(i)=10000d0
      do j=1,nsolute
         r(i,j)=(x(i)-x(j))**2+(y(i)-y(j))**2+(z(i)-z(j))**2 
         r(i,j)=dsqrt(r(i,j))
         if(r(i,j).lt.rmin(i))then
            rmin(i)=r(i,j)
         endif
      enddo
   enddo

! determine the distances to the geometrical center
! or to atom with index atidx
   if(lcom.or.atidx.gt.0)then
      do i=nsolute+1,natom
         rmin(i)=(x(i)-xt)**2+(y(i)-yt)**2+(z(i)-zt)**2 
         rmin(i)=dsqrt(rmin(i))
      enddo
   end if

! total number of molecules
   nmoltotal=(natom-nsolute)/natmol

!  Now we have to determine, which atom in each molecule is closest
   do imol=1,nmoltotal
      rmolmin(imol)=10000d0
      do iat=nsolute+1,nsolute+1+natmol
         if(rmin(iat).lt.rmolmin(imol))then
            rmolmin(imol)=rmin(iat)
         endif
      enddo
   enddo

   ifin=0
   do i=1,natom
    index(i)=maxatom
   enddo

! Here's where the magic happens.
! ###############################################

   do i=1,nmoltotal
      index(i)=1
      do j=1,nmoltotal

         if(i.eq.j) cycle

!        now we have to determine, which molecule is closer
         if(rmolmin(i).gt.rmolmin(j))then
          index(i)=index(i)+1
         endif

      enddo
      index_rev(index(i))=i
   enddo
       
   open(150,file='cut_qm.xyz')
   write(150,*)natmol*nmol+nsolute
   write(150,*)
   ! first write solute
   do idx=1,nsolute
      write(150,*)at(idx),x(idx),y(i),z(idx)
   end do
   ! now write ordered solvent molecules
   do imol=1,nmol
      do iat=1,natmol
         idx=nsolute+(index_rev(imol)-1)*natmol+iat
         write(150,*)at(idx),x(idx),y(i),z(idx)
      enddo
   enddo

   close(150)

!  now print the solvent that we left out
   open(150,file='cut_mm.xyz')
   write(150,*)natom-natmol*nmol-nsolute
   write(150,*)
   do imol=nmol+1,nmoltot
      do iat=1,natmol
         idx=nsolute+(index_rev(imol)-1)*natmol+iat
         write(150,*)at(idx),x(idx),y(i),z(idx)
      enddo
   enddo

   close(150)


   ifin=0

   do ii=1,nmol
      ifin=ifin+1
      i=index_rev(ii)
      atfin(ifin)=at(i)
      xfin(ifin)=x(i)
      yfin(ifin)=y(i)
      zfin(ifin)=z(i)
      do k=2,natmol
         ifin=ifin+1
         atfin(ifin)=at(i+k-1)
         xfin(ifin)=x(i+k-1)
         yfin(ifin)=y(i+k-1)
         zfin(ifin)=z(i+k-1)
       enddo
    enddo

      ! MM part
      ifin=0
      do ii=nmol+1,(natom-nsolute)/natmol
        ifin=ifin+1
        i=index_rev(ii)
        atmm(ifin)=at(i)
        xmm(ifin)=x(i)
        ymm(ifin)=y(i)
        zmm(ifin)=z(i)
        do k=2,natmol
         ifin=ifin+1
         atmm(ifin)=at(i+k-1)
         xmm(ifin)=x(i+k-1)
         ymm(ifin)=y(i+k-1)
         zmm(ifin)=z(i+k-1)
        enddo
      enddo

      open(150,file='cut_qm.xyz')
      write(150,*)natmol*nmol+nsolute
      write(150,*)
      do i=1,nsolute
       write(150,*)at(i),x(i),y(i),z(i)
      enddo
      do i=1,nmol*natmol
       write(150,*)atfin(i),xfin(i),yfin(i),zfin(i)
      enddo

      close(150)
      open(150,file='cut_mm.xyz')
      write(150,*)natom-natmol*nmol-nsolute
      write(150,*)
      do i=1,ifin
       write(150,*)atmm(i),xmm(i),ymm(i),zmm(i)
      enddo

      close(150)

      end

subroutine Get_cmdline(natmol, nmol, nsolute, rad, lcom, atidx)
implicit none
real*8,intent(inout)    :: rad
integer, intent(inout)  :: natmol, nmol, nsolute, atidx
logical, intent(inout)  :: lcom
character(len=100)      :: arg
integer                 :: i

i=0
do while (i < command_argument_count())
  i=i+1
  call get_command_argument(i, arg)
  
  select case (arg)
  case ('-h', '--help')
    call PrintHelp()
    stop
  case ('-u')
    i=i+1
    call get_command_argument(i, arg)
    read(arg,*)nsolute
  case ('-v')
    i=i+1
    call get_command_argument(i, arg)
    read(arg,*)nmol
    if (nmol.le.0)then
       call PrintHelp()
       write(*,*)'ERROR: Number of molecules must be a positive integer.'
       call PrintInputError()
    endif
  case ('-vu')
    i=i+1
    call get_command_argument(i, arg)
    read(arg,*)natmol
  case ('-r')
    i=i+1
    call get_command_argument(i, arg)
    read(arg,*)rad
    if (rad.le.0)then
       call PrintHelp()
       write(*,*)'ERROR: Radius must be positive.'
       call PrintInputError()
    endif
  case ('-i')
    i=i+1
    call get_command_argument(i, arg)
    read(arg,*)atidx
    if (atidx.le.0)then
       call PrintHelp()
       write(*,*)'ERROR: Atom index must be positive.'
       call PrintInputError()
    endif
  case ('-com')
    lcom=.true.
  case default
    call PrintHelp()
    write(*,*)'Invalid command line argument!'
    call PrintInputError()
  end select

  ! INPUT SANITY CHECK
  if(rad.gt.0.and.nmol.gt.0)then
     write(*,*)'ERROR: Conflicting options -v -r.'
     write(*,*)'You may cut EITHER constant number of solvent molecules,'
     write(*,*)'OR cut sphere of solvent of fixed radius.'
     call PrintHelp()
     call PrintInputError()
  end if

  if(nmol.lt.0.and.rad.lt.0)then
     call PrintHelp()
     write(*,*)'ERROR: Missing options -u or -r.'
     call PrintInputError()
  end if

  if(nsolute.lt.0)then
     call PrintHelp()
     write(*,*)'ERROR: Number of atoms in solute not specified.'
     call PrintInputError()
  end if

  if(natmol.lt.0)then
     call PrintHelp()
     write(*,*)'ERROR: Number of atoms in a solvent molecule must be positive.'
     call PrintInputError()
  end if

  if(rad.gt.0.and.atidx.le.0)then
     lcom=.true.
  end if

end do

end subroutine Get_cmdline

subroutine PrintHelp()
implicit none
    print '(a)', ''
    print '(a)', 'Program for cutting solvent molecules around a given solute.'
    print '(a)', 'You may cut either specific number of closest solvent molecules'
    print '(a)', 'or all solvent mocules within given radius.'
    print '(a)', ''
    print '(a)', 'USAGE: ./cut_sphere [OPTIONS] < input.xyz'
    print '(a)', ''
    print '(a)', 'cmdline options:'
    print '(a)', ''
    print '(a)', '  -h,    --help       Print this information and exit.'
    print '(a)', '  -u     <integer>    Number of atoms in the solute.'
    print '(a)', '  -va    <integer>    Number of atoms in one solvent molecule (default=3)'
    print '(a)', '  -v     <integer>    Number solvent molecules to cut.'
    print '(a)', '  -r     <radius>     Radius of the sphere to cut.'
    print '(a)', '  -i     <atidx>      Cut around the atom with index atidx.'
    print '(a)', '  -com                Cut around the geometrical center of molecule.'
    print '(a)', '                      This is default if -r is specified.'
end subroutine PrintHelp

subroutine PrintInputError()
  write(*,*)'Error during reading input. Exiting...'
  stop 1
end subroutine PrintInputError


