! Testing the shell interface to external ab initio programs.
! Here we mostly test various error conditions.
! The full interface is tested in tests/ABINITIO and tests/QMMM.
module test_interface
   use funit
   use mod_const, only: DP
   use mod_utils, only: del_file
   use mod_shell_interface_private
   implicit none
   integer, parameter :: NATOM = 2, NBEAD = 2
   real(DP), dimension(NATOM, NBEAD) :: x, y, z, fx, fy, fz

contains

   @before
   subroutine setup()
      use mod_files, only: stdout_to_devnull, stderr_to_stdout
      use mod_qmmm, only: natqm, natmm
      use mod_general, only: ipimd
      use mod_system, only: names

      ipimd = 1
      natqm = NATOM
      natmm = 0
      x = 1.0D0
      y = 1.0D0
      z = 1.0D0

      fx = 0.0D0
      fy = 0.0D0
      fz = 0.0D0

      allocate (names(NATOM), source='C')

      call stdout_to_devnull()
      call stderr_to_stdout()
   end subroutine setup

   @after
   subroutine teardown()
      use mod_files, only: reset_stdout, reset_stderr
      use mod_system, only: names

      call reset_stdout()
      call reset_stderr()
      deallocate (names)
   end subroutine teardown

   @test
   subroutine test_missing_script()
      character(len=*), parameter :: potential = 'dummy'
      character(:), allocatable :: shellscript

      shellscript = get_shellscript(potential)
      @assertExceptionRaised('Shell executable ./DUMMY/r.dummy does not exist')
   end subroutine

   @test
   subroutine test_missing_engrad_file()
      character(len=*), parameter :: engrad_fname = 'engrad.dat'
      logical :: abort = .false.
      integer :: u

      u = open_engrad_file(engrad_fname, abort)
      ! NOTE: Deleting the file via a close statement results in
      ! runtime error for certain compiler versions/compiler flags.
      close (u) ! status='delete')
      @assertTrue(abort)
      call del_file(engrad_fname)
   end subroutine

   @test
   subroutine test_shell_error()
      character(len=:), allocatable :: shellscript
      logical :: abort = .false.
      integer :: u

      shellscript = 'dummy.sh'
      open (newunit=u, file=shellscript, action='write')
      write (u, *) '#!/bin/bash'
      write (u, *) 'exit 2'
      close (u)
      call execute_command_line('chmod 755 '//shellscript)
      call call_shell(shellscript, it=10, iw=1, ipimd=1, abort=abort)
      call del_file(shellscript)

      @assertTrue(abort)
   end subroutine

   @test
   subroutine test_invalid_energy()
      character(len=*), parameter :: fname = 'dummy.dat'
      real(DP) :: energy
      logical :: abort = .false.
      integer :: u

      call del_file(fname)
      ! Working around a bug in Gfortran 7.3.0, where the inquire statement
      ! does not work for units generated by 'newunit'.
      u = 133
      open (unit=u, file=fname, status='new')
      energy = read_energy(u, abort)

      close (u, status='delete')
      @assertTrue(abort)
   end subroutine

   @test
   subroutine test_invalid_gradients()
      character(len=*), parameter :: fname = 'dummy.dat'
      logical :: abort = .false.
      integer :: u

      u = 100
      open (unit=u, file=fname, status='new')
      write (u, *) '# Invalid line'
      call read_forces(fx, fy, fz, num_atom=NATOM, iw=1, engrad_unit=u, abort=abort)

      close (u, status='delete')
      @assertTrue(abort)
   end subroutine
end module test_interface
