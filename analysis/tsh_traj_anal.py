#!/bin/env python3
# /// script
# requires-python = ">=3.9"
# dependencies = [
#     "matplotlib",
#     "numpy",
#     "PyQT6",
# ]
# ///
"""Analysis script for Surface Hopping trajectories generated by ABIN

Script for analyzing potential energy surfaces, energies and electronic populations along
individual trajectories from ABIN's Fewest Switches or Landau-Zener surface hopping simulations.

The script should be launched within the ABIN trajectory folder as:

    python3 tsh_traj_analysis.py

or:

    ./tsh_traj_analysis.py


Author: Jiri Janos 2025
"""

def parse_cmd():
    """Parse command-line arguments"""
    import argparse

    parser = argparse.ArgumentParser(
        description="Analyze Surface Hopping trajectories",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument("-s", "--save-fig", action="store_true", help="Save png figure")
    parser.add_argument("-eu", "--energy-units", choices=["eV", "au"], default="eV", help="Energy units")
    parser.add_argument(
        "-es",
        "--energy-shift",
        action="store_false",
        help="Shift curves so that the lowest state minimum has 0 energy",
    )
    parser.add_argument("-n", "--nstates", type=int, help="Number of states to plot (default: all)")
    args = parser.parse_args()
    return vars(args)


def file_exists(fname: str):
    from os.path import exists

    if not exists(fname):
        exit(f"ERROR: file '{fname}' does not exist")


config = parse_cmd()

# input files
popfile = "pop.dat"
pesfile = "PES.dat"
enfile = "energies.dat"

# check if files exist
file_exists(popfile)
file_exists(pesfile)
file_exists(enfile)

# Lazy imports to speed up help printing
import numpy as np  # noqa: E402
import matplotlib.pyplot as plt  # noqa: E402

# reading data from files
pop = np.genfromtxt(popfile)
data = np.genfromtxt(pesfile)
energies = np.genfromtxt(enfile)

# Set nstates to all unless specified otherwise, or check if nstates is valid
nstates = config["nstates"]
if nstates is None:
    nstates = len(data.T) - 1
elif nstates > len(data.T) - 1:
    exit(f"ERROR: nstates ({nstates}) is larger than the number of states in the data ({len(data.T) - 1})")
elif nstates < 1:
    exit(f"ERROR: nstates ({nstates}) must be at least 1")

# converting data to eV
if config["energy_units"] == "eV":
    data.T[1:, :] = data.T[1:, :] * 27.2114
    energies.T[1:, :] = energies.T[1:, :] * 27.2114
    enunits = "eV"
else:
    enunits = "a.u."

# shifting data
if config["energy_shift"]:
    minE = np.min(data.T[1:, :])
    data.T[1:, :] = data.T[1:, :] - minE
    energies.T[1, :] = energies.T[1, :] - minE
    energies.T[-1, :] = energies.T[-1, :] - minE

### plotting
colors = plt.cm.viridis(np.linspace(0, 0.8, nstates))
fig, axs = plt.subplots(4, 1, figsize=(8, 7.5), gridspec_kw={"height_ratios": [1, 2, 1, 1]}, sharex=True)

# plotting populations
for i in range(nstates):
    axs[0].plot(pop.T[0, :], pop.T[i + 2, :], color=colors[i], label=rf"$S_{i}$")

axs[0].plot(
    pop.T[0, :],
    pop.T[1, :] - 1,
    color="black",
    linestyle="dashed",
    label="act. state\nindex",
)

axs[0].set_ylabel("El. populations")
axs[0].legend(labelspacing=0)

# plotting PES
for i in range(0, nstates):
    axs[1].plot(data.T[0, :], data.T[i + 1, :], color=colors[i], label=rf"$S_{i}$")

axs[1].scatter(energies.T[0, 0:-1:5], energies.T[1, 0:-1:5], s=5, alpha=0.5, color="black")
axs[1].plot(
    energies.T[0, :],
    energies.T[1, :],
    linewidth=8,
    alpha=0.2,
    color="black",
    label="active",
)
axs[1].plot(
    energies.T[0, :],
    energies.T[-1, :],
    color="black",
    alpha=0.5,
    linestyle="dotted",
    label=r"$E_{tot}$",
)

axs[1].set_ylabel(f"Energy ({enunits})")
axs[1].legend(labelspacing=0)

# plotting kinetic energy
axs[2].plot(energies.T[0, :], energies.T[2, :], color="black", alpha=1, label=r"$E_k$")
axs[2].set_ylabel(f"Kin. energy ({enunits})")

# plotting total energy
for i in range(0, nstates):
    axs[3].scatter(
        energies.T[0, pop.T[1, :] == (i + 1)],
        energies.T[-1, pop.T[1, :] == (i + 1)] - energies.T[-1, 0],
        color=colors[i],
        s=10,
    )
axs[3].plot(energies.T[0, :], energies.T[-1, :] - energies.T[-1, 0], color="black", alpha=0.5)
axs[3].plot([energies.T[0, 0], energies.T[0, -1]], [0, 0], color="black", linestyle="dashed")

axs[3].set_ylabel(f"Total energy ({enunits})")
axs[3].set_xlabel("Time (fs)")

# setting minor ticks
for axis in axs:
    axis.minorticks_on()
    axis.tick_params("both", direction="in", which="both", top=True, right=True)

plt.tight_layout()
plt.subplots_adjust(hspace=0)

# save figure
if config["save_fig"]:
    plt.savefig("PES_pop", dpi=300)
plt.show()
