#!/usr/bin/env python3
# /// script
# requires-python = ">=3.9"
# dependencies = [
#     "matplotlib",
#     "numpy",
# ]
# ///
"""Analysis script for Surface Hopping trajectories generated by ABIN

Script for analyzing potential energy surfaces, energies and electronic populations along
individual trajectories from ABIN's Fewest Switches or Landau-Zener surface hopping simulations.

The script should be launched within the ABIN trajectory folder as:

    python3 tsh_traj_analysis.py

or:

    ./tsh_traj_analysis.py


You can also launch the script via 'uv' (https://github.com/astral-sh/uv)
which will automatically install all needed dependencies (numpy, matplotlib)
in a separate virtual environment:

    uv run tsh_traj_analysis.py

Author: Jiri Janos 2025
"""

import os.path

# ABIN output files that we need
POPULATION_FILE = "pop.dat"
PES_FILE = "PES.dat"
ENERGY_FILE = "energies.dat"

AUtoEV = 27.2114


def parse_cmd():
    """Parse command-line arguments"""
    import argparse

    parser = argparse.ArgumentParser(
        description="Analyze Surface Hopping trajectories",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument("-s", "--save-fig", action="store_true", help="Save png figure")
    parser.add_argument("-eu", "--energy-units", choices=["eV", "au"], default="eV", help="Energy units")
    parser.add_argument(
        "-es", 
        "--energy-shift",
        type=float,
        default=None,
        help="Energy shift parameter in energy-units. All energy curves will be shifted by this energy shift parameter. If the option is not specified, the ground-state energy at time zero will be set to 0.",
    )
    parser.add_argument("-n", "--nstates", type=int, help="Number of states to plot (default: all)")
    return parser.parse_args()


config = parse_cmd()

for fname in (POPULATION_FILE, PES_FILE, ENERGY_FILE):
    if not os.path.exists(fname):
        exit(f"ERROR: file '{fname}' does not exist")

# Lazy imports to speed up CLI help printing
import numpy as np  # noqa: E402
import matplotlib.pyplot as plt  # noqa: E402

# reading data from files
pop = np.genfromtxt(POPULATION_FILE)
data = np.genfromtxt(PES_FILE)
energies = np.genfromtxt(ENERGY_FILE)

# Set nstates to all unless specified otherwise, or check if nstates is valid
nstates_all = len(data.T) - 1
nstates = config.nstates
if nstates is None:
    nstates = nstates_all
elif nstates > nstates_all:
    exit(f"ERROR: nstates ({nstates}) is larger than the number of states in the data ({nstates_all})")
elif nstates < 1:
    exit(f"ERROR: nstates ({nstates}) must be at least 1")

# convert energy units
if config.energy_units == "eV":
    data.T[1:, :] = data.T[1:, :] * AUtoEV
    energies.T[1:, :] = energies.T[1:, :] * AUtoEV
    enunits = "eV"
else:
    enunits = "a.u."

# Shift energies
if config.energy_shift is None:
    minE = -np.min(data.T[1:, 0])
else:
    minE = config.energy_shift
data.T[1:, :] = data.T[1:, :] + minE # shifting PES
energies.T[1, :] = energies.T[1, :] + minE # shifting kinetic energy
energies.T[-1, :] = energies.T[-1, :] + minE # shifting total energy

### plotting
colors = plt.cm.viridis(np.linspace(0, 0.8, nstates))
fig, axs = plt.subplots(4, 1, figsize=(8, 7.5), gridspec_kw={"height_ratios": [1, 2, 1, 1]}, sharex=True)

# plotting populations
for i in range(nstates):
    axs[0].plot(pop.T[0, :], pop.T[i + 2, :], color=colors[i], label=rf"$S_{i}$")

axs[0].plot(
    pop.T[0, :],
    pop.T[1, :] - 1,
    color="black",
    linestyle="dashed",
    label="act. state\nindex",
)

axs[0].set_ylabel("El. populations")
axs[0].legend(labelspacing=0)

# plotting PES
for i in range(0, nstates):
    axs[1].plot(data.T[0, :], data.T[i + 1, :], color=colors[i], label=rf"$S_{i}$")

axs[1].scatter(energies.T[0, 0:-1:5], energies.T[1, 0:-1:5], s=5, alpha=0.5, color="black")
axs[1].plot(
    energies.T[0, :],
    energies.T[1, :],
    linewidth=8,
    alpha=0.2,
    color="black",
    label="active",
)
axs[1].plot(
    energies.T[0, :],
    energies.T[-1, :],
    color="black",
    alpha=0.5,
    linestyle="dotted",
    label=r"$E_{tot}$",
)

axs[1].set_ylabel(f"Energy ({enunits})")
axs[1].legend(labelspacing=0)

# plotting kinetic energy
axs[2].plot(energies.T[0, :], energies.T[2, :], color="black", alpha=1, label=r"$E_k$")
axs[2].set_ylabel(f"Kin. energy ({enunits})")

# plotting total energy
for i in range(0, nstates):
    axs[3].scatter(
        energies.T[0, pop.T[1, :] == (i + 1)],
        energies.T[-1, pop.T[1, :] == (i + 1)] - energies.T[-1, 0],
        color=colors[i],
        s=10,
    )
axs[3].plot(energies.T[0, :], energies.T[-1, :] - energies.T[-1, 0], color="black", alpha=0.5)
axs[3].plot([energies.T[0, 0], energies.T[0, -1]], [0, 0], color="black", linestyle="dashed")

axs[3].set_ylabel(f"Total energy ({enunits})")
axs[3].set_xlabel("Time (fs)")

# setting minor ticks
for axis in axs:
    axis.minorticks_on()
    axis.tick_params("both", direction="in", which="both", top=True, right=True)

plt.tight_layout()
plt.subplots_adjust(hspace=0)

# save figure
if config.save_fig:
    plt.savefig("PES_pop", dpi=300)
plt.show()
