#!/bin/bash
#
#   This script calculates the time-dependent couplings
#   as input file it needs two structures at time t and t+h,
#   and input file for GAMESS
DEBUG=0
#   This skript is tailored for CASSCF with analytical forces


#   Name of structure file at time t:        strTDC_1.str
#   Name of structure file at time t+h:      strTDC_2.str
#   Name of example input file for GAMESS:   gamTDC.inp
#

# not sure why we need to binaries here
# runoverlap is needed for OVERLAP calculations, which otherwise fails
runoverlap=/home/slavicek/GAMESS11A/gamess/rungms
rungms2=/home/sistik/GAMESS/INSTAL/gamess/rungms

#   Clearing the energy file if there is any
if [ -e fomo_sten.dat ]; then
  rm -r fomo_sten.dat
fi

STRFILE1=strTDC_1.str
STRFILE2=strTDC_2.str
if [ -e $STRFILE2 ]; then
  NAtom=`head -n 1 $STRFILE2 | awk -F" " '{print $1}'`
else
  echo "*** ERROR: The file $STRFILE2 cannot be found"
  echo "*** Program will now exit"
  exit 1
fi
INPUT=gamTDC.inp
if [ ! -e $INPUT ]; then
  echo "*** ERROR: No GAMESS input file found!"
  echo "*** Program will now exit"
  exit 1
fi
#    Extracting information from GAMESS input file
CHARGE=`grep ICHARG $INPUT | awk -F"ICHARG=" '{print $2}' | awk -F" " '{print $1}'`
if [ -z "$CHARGE" ]; then
  echo "*** ERROR: GAMESS input does not contain \"ICHARG\" keyword!"
  echo "*** Program will now exit"
  exit 1
fi
MULT=`grep MULT $INPUT | awk -F"MULT=" '{print $2}' | awk -F" " '{print $1}'`
if [ -z $MULT ]; then
  MULT=1
  SZ=0
else
  SZ=$(( $MULT - 1 ))
fi
BAZE=`grep BASIS $INPUT`
EndBasis=`echo "$BAZE" | grep -o END`
if [ ! $EndBasis ]; then
  echo "*** ERROR: Basis set specification is not on one line!"
  echo "*** Program will now exit"
  exit 1
fi
#
NStates=`grep NSTATE $INPUT | awk -F"NSTATE=" '{print $2}' | awk -F" " '{print $1}'`
if [ -z $NStates ]; then
  echo "*** ERROR: Number of states not specified!"
  echo "*** Program will now exit"
  exit 1
fi
#
NFrozen=`grep NFZC $INPUT | awk -F"NFZC=" '{print $2}' | awk -F" " '{print $1}'`
if [ -z $NFrozen ]; then
  echo "*** ERROR: Number of frozen (core) orbitals not specified!"
  echo "*** Program will now exit"
  exit 1
fi
#
NOccu=`grep NDOC $INPUT | awk -F"NDOC=" '{print $2}' | awk -F" " '{print $1}'`
if [ -z $NOccu ]; then
  echo "*** ERROR: Number of occupied orbitals not specified!"
  echo "*** Program will now exit"
  exit 1
fi
#
NOpen=`grep NVAL $INPUT | awk -F"NVAL=" '{print $2}' | awk -F" " '{print $1}'`
if [ -z $NOpen ]; then
  echo "*** ERROR: Number of open virtual orbitals not specified!"
  echo "*** Program will now exit"
  exit 1
fi
#
if [ -e str.state.tmp ]; then
  ForceState=`head -n 1 str.state.tmp`
else
  echo "*** ERROR: Could not find \"str.state.tmp\", which contains actual number of states!"
  echo "*** Program will now exit"
  exit 1
fi
if [ -e wstate.tmp ]; then
  rm -r wstate.tmp
fi
for ((i=1; i<$ForceState; i++)); do
  if [ "$i" -eq "1" ]; then
    echo -n "  WSTATE(1)=1.0," >> wstate.tmp
  else
    echo -n "1.0," >> wstate.tmp
  fi
done
echo "1.0" >> wstate.tmp
#
###########################################################
###########################################################
#  Making the GAMESS input files if necessary
#
#   time: t+h
if [ -d TIME2 ]; then
   cp -r TIME2 TIME2-OLD
  rm -r TIME2
  mkdir TIME2
else
  mkdir TIME2
fi
cd TIME2
echo " \$CONTRL COORD=UNIQUE
  SCFTYP=RHF  RUNTYP=ENERGY
  NOSYM=1 ICHARG=$CHARGE
  MAXIT=200 ISPHER=1
 \$END 
 \$SYSTEM MEMORY=80000000 \$END
 \$GUESS  GUESS=HUCKEL \$END" > orb_tdc2.inp
echo "$BAZE" >> orb_tdc2.inp
echo ' $DATA' >> orb_tdc2.inp
echo " tdc-cas orb time: t+h" >> orb_tdc2.inp
echo " C1" >> orb_tdc2.inp
/home/sistik/utility/GAMConvStr ../$STRFILE2 | tail -n $NAtom >> orb_tdc2.inp
echo ' $END' >> orb_tdc2.inp
#
#   now is the time to run orb_tdc2.inp
$rungms2 orb_tdc2.inp > orb_tdc2.out 2>../err.tdc2.tmp
Grace21=`grep "ddikick.x: exited gracefully." orb_tdc2.out`
if [ -z "$Grace21" ]; then
  echo "Fail to finish orb2 calculation."
  exit 1
fi
#
#   extracting usefull information about orbitals
NAOrb=`grep "NUMBER OF CARTESIAN GAUSSIAN BASIS FUNCTIONS" orb_tdc2.out | awk -F"=" '{print $2}' | awk -F" " '{print $1}'`
NMOrb=`grep "DIMENSIONS OF THE SYMMETRY SUBSPACES ARE" orb_tdc2.out -A1 | tail -n 1 | awk -F" " '{print $NF}'`
MODNFAOrb=`expr $NAOrb % 5`
if [ "$MODNFAOrb" ]; then
  NGrep=$(( ( ( $NAOrb / 5 ) + 1 ) * $NMOrb + 4 ))
else
  NGrep=$(( ( $NAOrb / 5 ) * $NMOrb + 4 ))
fi
NGrepOrb=$NGrep
if [ -e ../orbold.orb ]; then
  cp ../orbold.orb orb_tdc2.orb
else
  grep "CLOSED SHELL ORBITALS" orb_tdc2.dat -A$NGrep | tail -n $(( $NGrep - 2 )) > orb_tdc2.orb
fi
#
#   making input file for CASSCF on SCF orbitals
echo ' $CONTRL SCFTYP=MCSCF COORD=UNIQUE
 RUNTYP=ENERGY NOSYM=1' > cas_tdc2.inp
echo " ICHARG=$CHARGE MULT=$MULT ISPHER=1" >> cas_tdc2.inp
echo ' $END
 $SYSTEM MWORDS=100 $END' >> cas_tdc2.inp
echo "$BAZE" >> cas_tdc2.inp
echo " \$GUESS  GUESS=MOREAD  NORB=$NMOrb \$END" >> cas_tdc2.inp
echo ' $MCSCF CISTEP=ALDET MAXIT=200 $END' >> cas_tdc2.inp
echo " \$DET SZ=$SZ NSTATE=$NStates IROOT=$ForceState NCORE=$NFrozen NACT=$(( $NOccu + $NOpen ))" >> cas_tdc2.inp
cat ../wstate.tmp >> cas_tdc2.inp
echo "  PRTTOL=0.0005 ITERMX=500
  NELS=$(( $NOccu * 2 )) \$END
 \$DATA
 CASSCF for time: t+h
 C1" >> cas_tdc2.inp
/home/sistik/utility/GAMConvStr ../$STRFILE2 | tail -n $NAtom >> cas_tdc2.inp
echo ' $END' >> cas_tdc2.inp
cat orb_tdc2.orb >> cas_tdc2.inp
#
#   now is the time to run cas_tdc2.inp
$rungms2 cas_tdc2.inp > cas_tdc2.out 2>../err.tdc2_cas.tmp
Grace22=`grep "ddikick.x: exited gracefully." cas_tdc2.out`
if [ -z "$Grace22" ]; then
  echo "Fail to finish cas2 calculation."
  exit 1
fi
grep "OPTIMIZED MCSCF MO-S" cas_tdc2.dat -A$NGrep | tail -n $(( $NGrep - 2 )) > ../orbold.orb
#
#   making input file for CASSCF on CASSCF orbitals for GUGA
echo ' $CONTRL SCFTYP=MCSCF COORD=UNIQUE
 RUNTYP=ENERGY NOSYM=1' > guga_tdc2.inp
echo " ICHARG=$CHARGE MULT=$MULT ISPHER=1" >> guga_tdc2.inp
echo ' $END
 $SYSTEM MWORDS=100 $END' >> guga_tdc2.inp
echo "$BAZE" >> guga_tdc2.inp
echo " \$GUESS GUESS=MOREAD  NORB=$NMOrb \$END" >> guga_tdc2.inp
echo ' $MCSCF CISTEP=GUGA MAXIT=200 $END' >> guga_tdc2.inp
echo " \$GUGDIA NSTATE=$ForceState ITERMX=300 \$END" >> guga_tdc2.inp
echo " \$GUGDM2 " >> guga_tdc2.inp
cat ../wstate.tmp >> guga_tdc2.inp
echo " \$END " >> guga_tdc2.inp
echo " \$DRT GROUP=C1 FORS=.TRUE. NMCC=$NFrozen NDOC=$NOccu NVAL=$NOpen \$END" >> guga_tdc2.inp
echo " \$DATA
 CASSCF for time: t+h
 C1" >> guga_tdc2.inp
/home/sistik/utility/GAMConvStr ../$STRFILE2 | tail -n $NAtom >> guga_tdc2.inp
echo ' $END' >> guga_tdc2.inp
cat ../orbold.orb >> guga_tdc2.inp
#
#   now is the time to run guga_tdc2.inp
$rungms2 guga_tdc2.inp > guga_tdc2.out 2>../err.tdc2_guga.tmp
Grace23=`grep "ddikick.x: exited gracefully." guga_tdc2.out`
if [ -z "$Grace23" ]; then
  echo "Fail to finish guga2 calculation."
  exit 1
fi
#
#
cd ..
#
#
###########################################################
###########################################################
#  Extracting data from calculated files
NOrbCelk=$(( $NFrozen + $NOccu + $NOpen ))
MODNOrb=$(( $NOrbCelk % 5 ))
if [ "$MODNOrb" -eq "0" ]; then
  NMult=$(( $NOrbCelk / 5 ))
else
  NMult=$(( $NOrbCelk / 5 + 1 ))
fi
OrbGrepString="MCSCF OPTIMIZED ORBITALS"
#OrbGrepString="MCSCF NATURAL ORBITALS"
IniWhichOrb=`echo $OrbGrepString | grep -o NATURAL`
if [ $IniWhichOrb ]; then
  CoeffGrep=6
else
  CoeffGrep=5
fi
NGrep=$(( ( $NAOrb + $CoeffGrep ) * NMult ))
# 
#   The TIME2 data files (MO and CI expansion)
cd TIME2
echo "$NOrbCelk  $NAOrb" > ../orb_tdc2.temp
grep "$OrbGrepString" cas_tdc2.out -A$NGrep | tail -n $(( $NGrep - 1 )) >> ../orb_tdc2.temp
#
#   CSFs from fomo file
echo "$ForceState" > ../csf_tdc2.temp 
IniDirectDiag=`grep "SOLUTION FOUND WITH DIRECT METHOD" guga_tdc2.out | grep DIRECT`
NLineCI=`grep -n ' 1  ENERGY' guga_tdc2.out | tail -n 1 | awk -F":" '{print $1}'`
NLineDens=`grep -n 'DENSITY MATRIX OVER ACTIVE MO-S' guga_tdc2.out | awk -F":" '{print $1}'`
NLineDiff=$(( $NLineDens - $NLineCI - 1 ))
grep ' 1  ENERGY' guga_tdc2.out -A$NLineDiff | tail -n $(( $NLineDiff + 1 )) > ci.tmp
for ((i=1; i<=$ForceState; i++)); do
  EnCSF2[$i]=`grep " $i  ENERGY" ci.tmp | awk -F" " '{print $6}'`
#j#  EnCSF2[$i]=`echo "scale=6; ${EnCSF2[$i]}/1.0" | bc`
  NLineS1=`grep -n " $i  ENERGY =" ci.tmp | awk -F":" '{print $1}'`
  if [[ "$i" == "$ForceState" ]]; then
    NLineS2=`wc -l ci.tmp | awk -F" " '{print $1}'`
    NLineS2=$(( $NLineS2 + 1 ))
  else
    NLineS2=`grep -n " $(( $i + 1 ))  ENERGY =" ci.tmp | awk -F":" '{print $1}'`
  fi
  NDiffLine=$(( $NLineS2 - $NLineS1 - 2 ))
  NCIVect=$(( $NDiffLine - 3 ))
  echo "$i   $NCIVect   ${EnCSF2[$i]}" >> ../csf_tdc2.temp
  grep " $i  ENERGY =" ci.tmp -A$NDiffLine | tail -n $NCIVect >> ../csf_tdc2.temp
done
EnCSF2[$(( $ForceState + 1 ))]=0.1
rm ci.tmp
#
#   determinants
echo "$ForceState $(( $NFrozen + 1 ))  $NOrbCelk  $SZ" > ../ci_tdc2.temp
NLineCI=`grep -n '\-MCCI\- BASED ON OPTIMIZED ORBITALS' cas_tdc2.out | awk -F":" '{print $1}'`
NLineDens=`grep -n 'DENSITY MATRIX OVER ACTIVE MO-S' cas_tdc2.out | awk -F":" '{print $1}'`
NLineDiff=$(( $NLineDens - $NLineCI - 1 ))
grep '\-MCCI\- BASED ON OPTIMIZED ORBITALS' cas_tdc2.out -A$NLineDiff > ci.tmp
AktIndx=1
for ((i=1; i<=$NStates; i++)); do
  Energy=`grep -w "$i  ENERGY=" ci.tmp | awk -F" " '{print $4}'`
  StateSZ=`grep -w "$i  ENERGY=" ci.tmp | awk -F" " '{print $6}'`
##PorovEn=`echo "scale=8; $Energy/${EnCSF2[$AktIndx]}" | bc | awk -F" " '{printf "%.7f", $1}'`
##PorovEn=`echo "$PorovEn == 1" | bc`
  echo "in2: $i   $Energy   ${EnCSF2[$AktIndx]}    $PorovEn    $StateSZ" >> infstate.tmp
##if [[ "$PorovEn" != 1 ]]; then
##  continue
##fi
  SZAkt=`echo "scale=7; $StateSZ^2" | bc | awk '{printf "%.0f",$1}'`
  SZAkt=`echo "scale=7; sqrt($SZAkt)" | bc | awk '{printf "%.0f",$1}'`
  if [[ "$SZAkt" != "$SZ" ]]; then
    continue
  fi
  NLineS1=`grep -nw "$i  ENERGY=" ci.tmp | awk -F":" '{print $1}'`
  if [[ "$i" -eq "$NStates" ]]; then
    NLineS2=`wc -l ci.tmp | awk -F" " '{print $1}'`
    let NLineS2++
  else
    NLineS2=`grep -nw "$(( $i + 1 ))  ENERGY=" ci.tmp | awk -F":" '{print $1}'`
  fi
  NDiffLine=$(( $NLineS2 - $NLineS1 - 2 ))
  NCIVect=$(( $NDiffLine - 3 ))
  echo "$i   $Energy   $NCIVect   $StateSZ" >> ../ci_tdc2.temp
  grep -w "$i  ENERGY=" ci.tmp -A$NDiffLine | tail -n $NCIVect > state.tmp
  for ((j=1; j<=$NCIVect; j++)); do
    Alpha=`head -n $j state.tmp | tail -n 1 | awk -F"|" '{print $1}' | sed 's/0/ 0/g' | sed 's/1/ 1/g'`
    Beta=`head -n $j state.tmp | tail -n 1 | awk -F"|" '{print $2}' | sed 's/0/ 0/g' | sed 's/1/ 1/g'`
    Coeff=`head -n $j state.tmp | tail -n 1 | awk -F"|" '{print $3}'`
    echo "$Alpha  |  $Beta  | $Coeff" >> ../ci_tdc2.temp
  done
  AktIndx=$(( $AktIndx + 1 ))
done
rm ci.tmp state.tmp
if [[ "$AktIndx" -le "$ForceState" ]]; then
  echo "Line 504: Not enough states of the desired spin!"
  exit 1
fi
cd ..
#
###########################################################
#   For simulations one needs the gradient (analytical forces, numerical too slow)
#    first we create template for force calculation 
echo ' $CONTRL SCFTYP=MCSCF COORD=UNIQUE
 RUNTYP=NACME NOSYM=1 MAXIT=200' > forceTDC.inp
echo " ICHARG=$CHARGE MULT=$MULT ISPHER=1" >> forceTDC.inp
echo ' $END
 $SYSTEM MWORDS=100 $END' >> forceTDC.inp
echo "$BAZE" >> forceTDC.inp
echo " \$GUESS  GUESS=MOREAD  NORB=$NMOrb \$END" >> forceTDC.inp
echo ' $MCSCF CISTEP=ALDET MAXIT=200 $END' >> forceTDC.inp
echo " \$DET SZ=$SZ NSTATE=$NStates IROOT=$ForceState NCORE=$NFrozen NACT=$(( $NOccu + $NOpen ))" >> forceTDC.inp
cat wstate.tmp >> forceTDC.inp
echo "  PRTTOL=0.01 ITERMX=200
 NELS=$(( $NOccu * 2 )) \$END" >> forceTDC.inp
echo " \$CPMCHF GCRODR=.TRUE. MICIT=30 KICIT=10 RECLIN=.FALSE. MAXIT=500 \$END" >> forceTDC.inp
echo " \$DATA
 CASSCF analytical forces
 C1" >> forceTDC.inp
/home/sistik/utility/GAMConvStr $STRFILE2 | tail -n $NAtom >> forceTDC.inp
echo ' $END' >> forceTDC.inp
if [ -e orbold.orb ]; then
  cat orbold.orb >> forceTDC.inp
else
  grep "OPTIMIZED MCSCF MO-S" TIME2/cas_tdc2.dat -A$NGrepOrb | tail -n $(( $NGrepOrb - 2 )) >> forceTDC.inp
fi
#   run force calculation
if [ -e forceTDC.dat ]; then
  rm -r forceTDC.dat
fi
$rungms2 forceTDC.inp > forceTDC.out 2>err.force.tmp
GraceF=`grep "ddikick.x: exited gracefully." forceTDC.out`
if [ -z "$GraceF" ]; then
  echo "Fail to finish force calculation."
  exit
fi
echo $ForceState > anforce.dat
for ((i=1; i<=$ForceState; i++)); do
  grep "$i (OVERALL STATE" forceTDC.out -A$(( $NAtom + 3 )) | tail -n $(( $NAtom + 1 )) | sed  's/[a-z,A-Z]//g' >> anforce.dat
  echo " " >> anforce.dat
done
###########################################################

# Now check, whether we have data from previous time step
if [ ! -e orb_tdc1.temp ] || [ ! -e ci_tdc1.temp ] || [ ! -e $STRFILE1 ]; then
   echo "No data from previous step."
   echo "Setting TDC to zero and exiting."
   echo "$ForceState" > fomo_sten.dat
   grep '  ENERGY =' TIME2/guga_tdc2.out | tail -$ForceState | awk '{print $6}' >> fomo_sten.dat
   mv orb_tdc2.temp orb_tdc1.temp
   mv ci_tdc2.temp ci_tdc1.temp
   mv csf_tdc2.temp csf_tdc1.temp
   mv strTDC_2.str strTDC_1.str
   echo "0th time step: TDC set to 0." >  tdcoups.dat
   echo "0th time step: TDC set to 0." >>  tdcoups.dat
   for ((i=1;i<=$ForceState;i++)){
      echo -n "$i " >> tdcoups.dat
      for ((j=1;j<=$ForceState;j++)){
      echo -n " 0.00000000 " >> tdcoups.dat
      }
      echo "" >> tdcoups.dat
   }
   exit 0
fi
#  now the Overlap calculation 
if [ -d OVERLAP ]; then
  rm -r OVERLAP
  mkdir OVERLAP
else
  mkdir OVERLAP
fi
cd OVERLAP
echo ' $CONTRL SCFTYP=RHF
  RUNTYP=ENERGY' > overlap.inp
echo "  NOSYM=1 ICHARG=$(( $CHARGE * 2 ))
  MULT=$MULT NPRINT=3
 \$END
 \$SYSTEM MWORDS=50 \$END" >> overlap.inp
echo "$BAZE" >> overlap.inp
echo ' $DATA
 overlap (t,t+h)
 C1' >> overlap.inp
/home/sistik/utility/GAMConvStr ../$STRFILE1 | tail -n $NAtom >> overlap.inp
/home/sistik/utility/GAMConvStr ../$STRFILE2 | tail -n $NAtom >> overlap.inp
echo ' $END' >> overlap.inp
#
#   now is the time to run overlap.inp
$runoverlap overlap.inp > overlap.out 2>err.over.tmp
Grace3=`grep "ddikick.x: exited gracefully." overlap.out`
if [ -z "$Grace3" ]; then
  echo "Fail to finish overlap calculation."
  exit 1
fi
# Extracting information
NLineS1=`grep -n "OVERLAP MATRIX" overlap.out | head -n 1 | awk -F":" '{print $1}'`
NLineS2=`grep -n "BARE NUCLEUS HAMILTONIAN INTEGRALS" overlap.out | awk -F":" '{print $1}'`
NDiffLine=$(( $NLineS2 - $NLineS1 - 1 ))
grep -w " OVERLAP MATRIX" overlap.out -A$NDiffLine > ../over_tdc.temp 
cd ..
#
#
#   Running the FORTRAN part
./fTDCoups > asym_tdcoups.dat
#
#   Running the FORTRAN part (symetric formula, need asimetric tdcoups from previous run)
if [ -e before_asym_tdcoups.dat ]; then
  ./fTDCoups_sym > tdcoups.dat
else
  cp asym_tdcoups.dat tdcoups.dat
fi
#
###########################################################
#
#
#   Cleaning and preparing for the next run (if there is any)
cp TIME2/orb_tdc2.orb force_orb.tmp

if [[ $DEBUG -ne "1" ]];then
   rm -r force_orb.tmp wstate.tmp
   rm -r forceTDC.*
   rm -r OVERLAP over_tdc.temp
fi

mv orb_tdc2.temp orb_tdc1.temp
mv ci_tdc2.temp ci_tdc1.temp
mv csf_tdc2.temp csf_tdc1.temp
mv strTDC_2.str strTDC_1.str
cp asym_tdcoups.dat before_asym_tdcoups.dat

