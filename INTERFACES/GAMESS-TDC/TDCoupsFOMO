#!/bin/bash
#
# DHWARNING: This script requires nwritex=1 in the input.in.

#  This script calculates the time-dependent couplings
#    as input file it needs two structures at time t and t+h,
#    and input file for GAMESS
#   Name of structure file from previous step:  strTDC_1.str
#   Name of structure file at the current time step: strTDC_2.str
#   Name of example input file for GAMESS:   gamTDC.inp
#

runfomo=/home/slavicek/gamess04/trunk/rungms
rungamess=/home/sistik/GAMESS/INSTAL/gamess/rungms
runoverlap=/home/slavicek/GAMESS11A/gamess/rungms

#Threshold for energy jump in numerical forces
deltaE=0.50 #eV

#   Clearing the energy file if there is any
rm -f fomo_sten.dat tdcoups.dat ../tdcoups.dat

#
#  Check the input files
STRFILE1=strTDC_1.str
STRFILE2=strTDC_2.str
if [ -e $STRFILE2 ]; then
  NAtom=`head -n 1 $STRFILE2 | awk -F" " '{print $1}'`
  if [ -z "$NAtom" ]; then
    echo "*** ERROR: Number of atoms is empty (file 2)."
    echo "*** Program will now exit"
    exit 1
  fi
else
  echo "*** ERROR: The file $STRFILE2 cannot be found"
  echo "*** Program will now exit"
  exit 1
fi
INPUT=gamTDC.inp
if [ ! -e $INPUT ]; then
  echo "*** ERROR: No GAMESS input file found!"
  echo "*** Program will now exit"
  exit 1
fi

#    Extracting information from GAMESS input file
CHARGE=`grep ICHARG $INPUT | awk -F"ICHARG=" '{print $2}' | awk -F" " '{print $1}'`
if [ -z "$CHARGE" ]; then
  echo "*** ERROR: GAMESS input does not contain \"ICHARG\" keyword!"
  echo "*** Program will now exit"
  exit 1
fi
MULT=`grep MULT $INPUT | awk -F"MULT=" '{print $2}' | awk -F" " '{print $1}'`
if [ -z $MULT ]; then
  MULT=1
  SZ=0
else
  SZ=$(( $MULT - 1 ))
fi
BAZE=`grep BASIS $INPUT`
EndBasis=`echo "$BAZE" | grep -o END`
if [ ! $EndBasis ]; then
  echo "*** ERROR: Basis set specification is not on one line!"
  echo "*** Program will now exit"
  exit 1
fi
NStates=`grep NSTATE $INPUT | awk -F"NSTATE=" '{print $2}' | awk -F" " '{print $1}'`
if [ -z $NStates ]; then
  echo "*** ERROR: Number of states not specified!"
  echo "*** Program will now exit"
  exit 1
fi
NFrozen=`grep NFZC $INPUT | awk -F"NFZC=" '{print $2}' | awk -F" " '{print $1}'`
if [ -z $NFrozen ]; then
  echo "*** ERROR: Number of frozen (core) orbitals not specified!"
  echo "*** Program will now exit"
  exit 1
fi
NDoubleOccu=$(grep NFCLOS $INPUT | awk -F"NFCLOS=" '{print $2}' | awk -F" " '{print $1}')
if [[ -z $NDoubleOccu ]]; then
  echo "*** ERROR: Number of doubly occupied orbitals in FOMO not specified!"
  echo "*** Program will now exit"
  exit 1
fi
NOccu=`grep NDOC $INPUT | awk -F"NDOC=" '{print $2}' | awk -F" " '{print $1}'`
if [ -z $NOccu ]; then
  echo "*** ERROR: Number of occupied orbitals not specified!"
  echo "*** Program will now exit"
  exit 1
fi
NOpen=`grep NVAL $INPUT | awk -F"NVAL=" '{print $2}' | awk -F" " '{print $1}'`
if [ -z $NOpen ]; then
  echo "*** ERROR: Number of open virtual orbitals not specified!"
  echo "*** Program will now exit"
  exit 1
fi
NVirt=`grep NFVIRT $INPUT | awk -F"NFVIRT=" '{print $2}' | awk -F" " '{print $1}'`
if [ -z $NVirt ]; then
  echo "*** ERROR: Number of frozen virtual orbitals not specified!"
  echo "*** Program will now exit"
  exit 1
fi
FLOWID=`grep FLOWID $INPUT | awk -F"FLOWID=" '{print $2}' | awk -F" " '{print $1}'`
if [ -z $FLOWID ]; then
  echo "*** ERROR: Variable \"FLOWID\" not found in the input!"
  echo "*** Program will now exit"
  exit 1
fi
OCCUP=$(grep "OCCUP(1)" $INPUT | awk -F "\$END" '{print $1}')
if [[ -z $OCCUP ]]; then
  echo "*** ERROR: Variable \"OCCUP(1)\" not found in the input!"
  echo "*** Program will now exit"
  exit 1
fi
if [ -e str.state.tmp ]; then
  ForceState=`head -n 1 str.state.tmp`
else
  echo "*** ERROR: Could not find \"str.state.tmp\", which contains actual number of states!"
  echo "*** Program will now exit"
  exit 1
fi
if [ -e wstate.tmp ]; then
  rm -r wstate.tmp
fi
for ((i=1; i<$ForceState; i++)); do
  if [ "$i" -eq "1" ]; then
    echo -n "  WSTATE(1)=1.0," >> wstate.tmp
  else
    echo -n "1.0," >> wstate.tmp
  fi
done
echo "1.0" >> wstate.tmp
#
###########################################################
function check_energy {
   local reference=$1
   local output=$2
   local dE=$3
   nstates=$ForceState
   cp $reference en.temp
   grep '  ENERGY =' $output | awk '{print $6}' >> en.temp
   awk -v nstate="$nstates" -v dE="$dE" ' function abs(x){return ((x < 0.0) ? -x : x)} \
   {en[NR]=$1}END{for(i=1;i<=nstate;i++) {if(abs(en[i]-en[i+nstate])>dE/27.2114){exit 1}}}' en.temp
   return $?
}
###########################################################
#  Making the GAMESS input files if necessary
#
#   time: t+h
if [ -d TIME2 ]; then
  rm -r TIME2
  mkdir TIME2
else
  mkdir TIME2
fi
cd TIME2
echo " \$CONTRL SCFTYP=RHF, RUNTYP=ENERGY NOSYM=1" > fomo_tdc2.inp
echo "  IOCCU=1 ICHARG=$CHARGE COORD=UNIQUE MAXIT=200 ISPHER=1" >> fomo_tdc2.inp
echo "  CITYP=GUGA \$END" >> fomo_tdc2.inp
echo "$BAZE" >> fomo_tdc2.inp
echo " \$SYSTEM MWORDS=100 \$END" >> fomo_tdc2.inp
echo " \$INTGRL NOPK=1 \$END" >> fomo_tdc2.inp 
echo " \$CIDRT GROUP=C1 FORS=.TRUE. NFZC=$NFrozen NDOC=$NOccu NVAL=$NOpen \$END" >> fomo_tdc2.inp
echo " \$GUGDIA NSTATE=$ForceState ITERMX=300 \$END" >> fomo_tdc2.inp
echo " \$GUESS GUESS=HUCKEL \$END" >> fomo_tdc2.inp
echo " \$OCCUPA FLOCC=GAUSSFLC FLOWID=$FLOWID NFVIRT=$NVirt NFCLOS=$NDoubleOccu" >> fomo_tdc2.inp
echo $OCCUP >> fomo_tdc2.inp
echo \$END >> fomo_tdc2.inp
echo ' $DATA' >> fomo_tdc2.inp
echo " tdc fomo time: t+h" >> fomo_tdc2.inp
echo " C1" >> fomo_tdc2.inp
../GAMConvStr ../$STRFILE2 | tail -n $NAtom >> fomo_tdc2.inp
echo ' $END' >> fomo_tdc2.inp
#
#   if there are orbitals from previous calculation use them
cp fomo_tdc2.inp fzal2.temp
if [ -e ../orbold.orb ]; then
  NOrbOld=`tail -n 2 ../orbold.orb | head -n -1 | awk -F" " '{print $1}'`
  cat fzal2.temp | sed "s/HUCKEL/MOREAD NORB=$NOrbOld/" > fomo_tdc2.inp
  cat ../orbold.orb >> fomo_tdc2.inp
fi
#
#   now is the time to run fomo_tdc2.inp
$runfomo fomo_tdc2.inp > fomo_tdc2.out 2>../err.tdc2.tmp
Grace21=`grep "ddikick.x: exited gracefully." fomo_tdc2.out`
#
#   extracting usefull information about orbitals
NAOrb=`grep "NUMBER OF CARTESIAN GAUSSIAN BASIS FUNCTIONS" fomo_tdc2.out | awk -F"=" '{print $2}' | awk -F" " '{print $1}'`
NMOrb=`grep "DIMENSIONS OF THE SYMMETRY SUBSPACES ARE" fomo_tdc2.out -A1 | tail -n 1 | awk -F" " '{print $NF}'`

if [[ -z $NMOrb ]];then
   echo "Something went horribly wrong in the first fomo calculation."
   echo "See file TIME2/fomo_tdc2.out"
   exit 1
fi

MODNFAOrb=`expr $NAOrb % 5`
if [ "$MODNFAOrb" -ne "0" ]; then
  NGrep=$(( ( ( $NAOrb / 5 ) + 1 ) * $NMOrb + 4 ))
else
  NGrep=$(( ( $NAOrb / 5 ) * $NMOrb + 4 ))
fi
NGrepOrb=$NGrep
grep "CLOSED SHELL ORBITALS" fomo_tdc2.dat -A$NGrep | tail -n $(( $NGrep - 2 )) > fomo_tdc2.orb
#
#   if there was a problem with no convergence
if [ -z "$Grace21" ]; then
  echo "Fail to finish fomo2 calculation."
  ConvProb=`grep "SCF IS UNCONVERGED, TOO MANY ITERATIONS" fomo_tdc2.out`
  DavidProb=`grep "DAVIDSON METHOD NOT CONVERGED AFTER" fomo_tdc2.out`
  if [ ! -z "$ConvProb" ] && [ -z "$DavidProb" ]; then
    echo "Try new orbitals..."
    cat fzal2.temp | sed "s/HUCKEL/MOREAD NORB=$NMOrb/" > fomo_tdc2.inp
    cat fomo_tdc2.orb >> fomo_tdc2.inp
    $runfomo fomo_tdc2.inp > fomo_tdc2.out 2>../err.tdc2.tmp
    grep "CLOSED SHELL ORBITALS" fomo_tdc2.dat -A$NGrep | tail -n $(( $NGrep - 2 )) > fomo_tdc2.orb
    Grace21b=`grep "ddikick.x: exited gracefully." fomo_tdc2.out`
    if [ -z "$Grace21b" ]; then
      ConvProbb=`grep "SCF IS UNCONVERGED, TOO MANY ITERATIONS" fomo_tdc2.out`
      DavidProb=`grep "DAVIDSON METHOD NOT CONVERGED AFTER" fomo_tdc2.out`
      if [ ! -z "$ConvProbb" ] && [ -z "$DavidProb" ]; then
        echo "Not even new orbitals. Try to do it without..."
        cp fzal2.temp fomo_tdc2.inp
        $runfomo fomo_tdc2.inp > fomo_tdc2.out 2>../err.tdc2.tmp
        grep "CLOSED SHELL ORBITALS" fomo_tdc2.dat -A$NGrep | tail -n $(( $NGrep - 2 )) > fomo_tdc2.orb
        Grace21c=`grep "ddikick.x: exited gracefully." fomo_tdc2.out`
        if [ -z "$Grace21c" ]; then
          echo "Not even no starting orbitals. Or is the error somewhere else?"
          exit 1
        else
          if [ -e ci_tdc1.temp ]; then
            rm -r ci_tdc1.temp
          fi
        fi
      else
        echo "Fail to finish fomo2 calc again."
        exit 1
      fi
    fi
  else
    exit 1
  fi
fi

#DH mod: HERE: make energy comparison for fomo
# only really works if nwritex=1!!!
tail -1 ../../PES.dat | awk '{if($1!="#"){for(i=2;i<=NF;i++) print $i}else{exit 1}}' > pes.dat

if [[ $? -ne 1 ]];then   #in the first step, we need to avoid this
   check_energy pes.dat fomo_tdc2.out 0.50

   if [[ $? -eq 1 ]];then
      echo "WARNING: FOMO energy jump in fomo2 calculation."
      echo "Try Huckel guess..."
      cp fzal2.temp fomo_tdc2.inp
      cp fomo_tdc2.out fomo_tdc2.out.error
      $runfomo fomo_tdc2.inp > fomo_tdc2.out 2>../err.tdc2.tmp
      grep "CLOSED SHELL ORBITALS" fomo_tdc2.dat -A$NGrep | tail -n $(( $NGrep - 2 )) > fomo_tdc2.orb
      check_energy pes.dat fomo_tdc2.out 0.50
      if [[ $? -eq 1 ]];then
         echo "ERROR: FOMO energy jump in fomo2 calculation."
         echo "Exiting..."
         exit 1
      fi
   fi

fi

cp fomo_tdc2.orb ../orbold.orb
#
#   making input file for CASSCF on FOMO orbitals
echo ' $CONTRL SCFTYP=NONE COORD=UNIQUE
 RUNTYP=ENERGY NOSYM=1 CITYP=ALDET' > cas_tdc2.inp
echo " ICHARG=$CHARGE MULT=$MULT ISPHER=1" >> cas_tdc2.inp
echo ' $END
 $SYSTEM MWORDS=100 $END' >> cas_tdc2.inp
echo "$BAZE" >> cas_tdc2.inp
echo " \$GUESS  GUESS=MOREAD  NORB=$NMOrb \$END" >> cas_tdc2.inp
echo " \$CIDET SZ=$SZ NSTATE=$NStates NCORE=$NFrozen NACT=$(( $NOccu + $NOpen )) " >> cas_tdc2.inp
 echo "  PRTTOL=0.0005 ITERMX=500 CVGTOL=0.5e-5
 NELS=$(( $NOccu * 2 )) \$END
 \$DATA
 CASCI on FOMO orbitals for time: t+h
 C1" >> cas_tdc2.inp
../GAMConvStr ../$STRFILE2 | tail -n $NAtom >> cas_tdc2.inp
echo ' $END
  ' >> cas_tdc2.inp
cat fomo_tdc2.orb >> cas_tdc2.inp
#
#   now is the time to run cas_tdc2.inp
$rungamess cas_tdc2.inp > cas_tdc2.out 2>../err.tdc2_cas.tmp
cas2state=$?
#
#   if there is a problem with a number of states, not converging, lover that number and rerun the calculation
Grace22=`grep "DETERMINANT FULL CI FAILED TO CONVERGE" cas_tdc2.out`
cp cas_tdc2.inp czal2.inp
NConvState=$NStates
while [[ ! -z "$Grace22" ]]; do
  NConvState=$(( $NConvState - 1 ))
  echo "cas2 again: NStates = $NConvState"
  cat czal2.inp | sed "s/NSTATE=$NStates/NSTATE=$NConvState/" > cas_tdc2.inp
  $rungamess cas_tdc2.inp > cas_tdc2.out 2>../err.tdc2_cas.tmp
  cas2state=$?
  echo $cas2state > o
  Grace22=`grep "DETERMINANT FULL CI FAILED TO CONVERGE" cas_tdc2.out`
done
Grace23=`grep "BUT FEWER OF THESE THAN" cas_tdc2.out`
if [[ ! -z "$Grace23" ]]; then
  echo "fail to finish cas2 calculation. Not enough states."
  exit 1
elif [[ $cas2state -ne 0 ]];then
   echo "Some error occured in the cas2 calculation."
   echo "See file TIME2/cas_tdc2.out"
fi
#
#
cd ..
#
#
###########################################################
###########################################################
#  Extracting data from calculated files
NOrbCelk=$(( $NFrozen + $NOccu + $NOpen ))
MODNOrb=$(( $NOrbCelk % 5 ))
if [ "$MODNOrb" -eq "0" ]; then
  NMult=$(( $NOrbCelk / 5 ))
else
  NMult=$(( $NOrbCelk / 5 + 1 ))
fi
#OrbGrepString="MCSCF OPTIMIZED ORBITALS"
#OrbGrepString="MCSCF NATURAL ORBITALS"
OrbGrepString="EIGENVECTORS"
IniWhichOrb=`echo $OrbGrepString | grep -o NATURAL`
if [ $IniWhichOrb ]; then
  CoeffGrep=6
else
  CoeffGrep=5
fi
NGrep=$(( ( $NAOrb + $CoeffGrep ) * NMult ))
# 
cd TIME2
echo "$NOrbCelk  $NAOrb" > ../orb_tdc2.temp
grep "$OrbGrepString" fomo_tdc2.out -A$NGrep | tail -n $(( $NGrep - 1 )) >> ../orb_tdc2.temp
#
#   CSFs from fomo file
echo "$ForceState" > ../csf_tdc2.temp 
IniDirectDiag=`grep "SOLUTION FOUND WITH DIRECT METHOD" fomo_tdc2.out | grep DIRECT`
NLineCI=`grep -n ' 1  ENERGY' fomo_tdc2.out | awk -F":" '{print $1}'`
NLineDens=`grep -n 'END OF CI-MATRIX DIAGONALIZATION' fomo_tdc2.out | awk -F":" '{print $1}'`
NLineDiff=$(( $NLineDens - $NLineCI ))
grep ' 1  ENERGY' fomo_tdc2.out -A$NLineDiff > ci.tmp
for ((i=1; i<=$ForceState; i++)); do
  EnCSF2[$i]=`grep " $i  ENERGY" ci.tmp | awk -F" " '{print $6}'`
#j#  EnCSF2[$i]=`echo "scale=6; ${EnCSF2[$i]}/1.0" | bc`
  NLineS1=`grep -n " $i  ENERGY =" ci.tmp | awk -F":" '{print $1}'`
  if [[ "$i" == "$ForceState" ]]; then
    NLineS2=`grep -n "END OF CI-MATRIX DIAGONALIZATION" ci.tmp | awk -F":" '{print $1}'`
    if [ -z "$IniDirectDiag" ]; then
      NLineS2=$(( $NLineS2 + 1 ))
    else
      NLineS2=$(( $NLineS2 - 3 ))
    fi
  else
    NLineS2=`grep -n " $(( $i + 1 ))  ENERGY =" ci.tmp | awk -F":" '{print $1}'`
  fi
  NDiffLine=$(( $NLineS2 - $NLineS1 - 2 ))
  NCIVect=$(( $NDiffLine - 3 ))
  echo "$i   $NCIVect   ${EnCSF2[$i]}" >> ../csf_tdc2.temp
  grep " $i  ENERGY =" ci.tmp -A$NDiffLine | tail -n $NCIVect >> ../csf_tdc2.temp
done
EnCSF2[$(( $ForceState + 1 ))]=0.1
rm ci.tmp
#
#   determinants
echo "$ForceState $(( $NFrozen + 1 ))  $NOrbCelk  $SZ" > ../ci_tdc2.temp
NLineCI=`grep -n ' 1  ENERGY' cas_tdc2.out | awk -F":" '{print $1}'`
NLineDens=`grep -n 'DONE WITH DETERMINANT CI COMPUTATION' cas_tdc2.out | awk -F":" '{print $1}'`
let NLineDiff=NLineDens-NLineCI
grep ' 1  ENERGY' cas_tdc2.out -A$NLineDiff > ci.tmp
AktIndx=1
for ((i=1; i<=$NStates; i++)); do
  Energy=`grep " $i  ENERGY=" ci.tmp | awk -F" " '{print $4}'`
  StateSZ=`grep " $i  ENERGY=" ci.tmp | awk -F" " '{print $6}'`
#j#  Energy=`echo "scale=6; $Energy/1.0" | bc`
#j#  PorovEn=`echo "$Energy == ${EnCSF2[$AktIndx]}" | bc`
  PorovEn=`echo "scale=8; $Energy/${EnCSF2[$AktIndx]}" | bc | awk -F" " '{printf "%.7f", $1}'`
  PorovEn=`echo "$PorovEn == 1" | bc`
  echo "in2: $i   $Energy   ${EnCSF2[$AktIndx]}    $PorovEn    $StateSZ" >> infstate.tmp
  SZAkt=`echo "scale=7; $StateSZ^2" | bc | awk '{printf "%.0f",$1}'`
  SZAkt=`echo "scale=7; sqrt($SZAkt)" | bc | awk '{printf "%.0f",$1}'`
  if [[ "$SZAkt" != "$SZ" ]]; then
    continue
  fi
  # checking, whether energies from fomo_tdc and cas_tdc match
  if [[ "$PorovEn" != 1 ]]; then
   echo "Error: CASCI energies from different GAMESS routines do not match."
   echo "Check files GAMESS-TDC/TIME2/cas_tdc2.out and fomo_tdc2.out"
   exit 1
#    continue
  fi
  NLineS1=`grep -n " $i  ENERGY=" ci.tmp | awk -F":" '{print $1}'`
  if [[ "$i" -eq $NStates ]]; then
    NLineS2=$(cat ci.tmp | wc -l)
    let NLineS2++
  else
    NLineS2=`grep -n " $(( $i + 1 ))  ENERGY=" ci.tmp | awk -F":" '{print $1}'`
  fi
  NDiffLine=$(( $NLineS2 - $NLineS1 - 2 ))
  NCIVect=$(( $NDiffLine - 3 ))
  echo "$i   $Energy   $NCIVect   $StateSZ" >> ../ci_tdc2.temp
  grep " $i  ENERGY=" ci.tmp -A$NDiffLine | tail -n $NCIVect > state.tmp
  for ((j=1; j<=$NCIVect; j++)); do
    Alpha=`head -n $j state.tmp | tail -n 1 | awk -F"|" '{print $1}' | sed 's/0/ 0/g' | sed 's/1/ 1/g'`
    Beta=`head -n $j state.tmp | tail -n 1 | awk -F"|" '{print $2}' | sed 's/0/ 0/g' | sed 's/1/ 1/g'`
    Coeff=`head -n $j state.tmp | tail -n 1 | awk -F"|" '{print $3}'`
    echo "$Alpha  |  $Beta  | $Coeff" >> ../ci_tdc2.temp
  done
  AktIndx=$(( $AktIndx + 1 ))
done
if [[ "$AktIndx" -le "$ForceState" ]]; then
  echo "TDCoupsFOMO:Line630: Not enough states of the desired spin!"
  exit 1
fi
rm ci.tmp state.tmp
cd ..
#


###########################################################
###########################################################
#   For simulations one needs the gradient (numerical is the only option)
#    first the adjustment of gamTDC.inp because we dont need as much states as in CASSCF recalc

if [ -d NUM_FORCE ]; then
  rm -r NUM_FORCE
fi
mkdir NUM_FORCE

#
#  Generating all structures involved in numreical derivation
./fNumForceGenStr < $STRFILE2 > strall.temp
#
#  Now we calculate all energies
#     Determine the number of structures
NLines=`wc -l strall.temp | awk -F" " '{print $1}'`
NStruct=$(( $NLines / ( $NAtom + 2 ) ))
NCycle=$(( $NStruct / 2 ))
#
#     Save some data
#
cd NUM_FORCE
#
grep '  ENERGY =' ../TIME2/fomo_tdc2.out | awk '{print $6}' > ref_en.dat
# The following 2 lines are for 0th step, because fomo_sten is made after OVERLAP calculations
echo $ForceState > ../fomo_sten.dat
cat  ref_en.dat >> ../fomo_sten.dat

#     make the template file
FILE="template.inp"
echo " \$CONTRL SCFTYP=RHF, RUNTYP=ENERGY NOSYM=1" > $FILE
echo "  IOCCU=1 ICHARG=$CHARGE COORD=UNIQUE MAXIT=200 ISPHER=1" >> $FILE
echo "  CITYP=GUGA \$END" >> $FILE
echo "$BAZE" >> $FILE
echo " \$SYSTEM MWORDS=100 \$END" >> $FILE
echo " \$INTGRL NOPK=1 \$END" >> $FILE
echo " \$CIDRT GROUP=C1 FORS=.TRUE. NFZC=$NFrozen NDOC=$NOccu NVAL=$NOpen \$END" >> $FILE
# DHmod: decrease convergence tresholds, better for numerical forces
echo " \$SCF CONV=1.0d-7 \$END" >> $FILE
echo " \$GUGDIA NSTATE=$ForceState ITERMX=200 CVGTOL=1e-6 \$END" >> $FILE
#echo " \$GUESS GUESS=MOREAD NORB=$NMOrb \$END" >> $FILE
echo " \$GUESS GUESS=HUCKEL \$END" >> $FILE
echo " \$OCCUPA FLOCC=GAUSSFLC FLOWID=$FLOWID NFVIRT=$NVirt NFCLOS=$NDoubleOccu" >> $FILE
echo $OCCUP >> $FILE
echo \$END >> $FILE
echo ' $DATA' >> $FILE
echo " force num_der" >> $FILE
echo " C1" >> $FILE
#
#     calculates energies in GAMESS

function calc_numforce {

   if [ -e ../force_en.temp ]; then
      rm -r ../force_en.temp
   fi

   echo $NCycle >> ../force_en.temp
   echo $ForceState >> ../force_en.temp

 for ((i=1; i<=$NCycle; i++)); do
# #
# #     First the minus part:
    FILE=force_gam_$i"m.inp"
    NHead=$(( ( $NAtom + 2 ) * $i * 2 ))
    NTail=$(( ( $NAtom + 2 ) * 2 ))
    head -n $NHead ../strall.temp | tail -n $NTail > stract.temp
    cat template.inp > $FILE
    ../GAMConvStr stract.temp | head -n $(( $NAtom + 2 )) | tail -n $NAtom >> $FILE
    echo ' $END' >> $FILE
    cat ../orbold.orb >> $FILE
    $runfomo $FILE > $FILE.out 2> /dev/null
    IsDoneWell1=`grep "ddikick.x: exited gracefully." $FILE.out`
    check_energy ref_en.dat $FILE.out $deltaE
    EnergyOK=$?
    if [[ -z "$IsDoneWell1" || $EnergyOK -ne 0 ]]; then
       echo "Failed calculation of numerical forces: $FILE"
       echo "Trying with MOguess"
       mv $FILE.out $FILE.out.error
       cat $FILE | sed 's/HUCKEL/MOREAD NORB=$NMOrb/' > temp
       mv temp $FILE
       $runfomo $FILE > $FILE.out 2> /dev/null
       IsDoneWell1=`grep "ddikick.x: exited gracefully." $FILE.out`
    fi
    #DH; checking for energy jump
    check_energy ref_en.dat $FILE.out $deltaE
    EnergyOK=$?
    if [[ -z "$IsDoneWell1" || $EnergyOK -ne 0 ]]; then
        echo "ERROR: Numerical gradient failed calculation at step $i-m"
        return 1
    fi

    for ((j=1; j<=$ForceState; j++)); do
      EnergyF[$j]=`grep "$j  ENERGY" $FILE.out | tail -n 1 | awk -F"=" '{print $2}' | awk -F" " '{print $1}'`
    done
    echo ${EnergyF[@]} >> ../force_en.temp
# #
# #     Second the plus part:
    FILE=force_gam_$i"p.inp"
    cat template.inp > $FILE
    /home/sistik/utility/GAMConvStr stract.temp | tail -n $NAtom >> $FILE
    echo ' $END' >> $FILE
    cat ../orbold.orb >> $FILE
    $runfomo $FILE > $FILE.out 2> /dev/null
    IsDoneWell2=`grep "ddikick.x: exited gracefully." $FILE.out`
    check_energy ref_en.dat $FILE.out $deltaE
    EnergyOK=$?
    if [[ -z "$IsDoneWell2" || $EnergyOK -ne 0 ]]; then
       echo "Failed calculation of numerical forces: $FILE"
       echo "Trying with MOguess"
       mv $FILE.out $FILE.out.error
       cat $FILE | sed "s/HUCKEL/MOREAD NORB=$NMOrb/" > temp
       mv temp $FILE
       $runfomo $FILE > $FILE.out 2> /dev/null
       IsDoneWell2=`grep "ddikick.x: exited gracefully." $FILE.out`
    fi
    #DH; checking for energy jump
    check_energy ref_en.dat $FILE.out $deltaE
    EnergyOK=$?
    if [[ -z "$IsDoneWell2" || $EnergyOK -ne 0 ]]; then
        echo "ERROR: Numerical gradient failed calculation at step $i-p" 
        return 1
    fi
    for ((j=1; j<=$ForceState; j++)); do
      EnergyF[$j]=`grep "$j  ENERGY" $FILE.out | tail -n 1 | awk -F"=" '{print $2}' | awk -F" " '{print $1}'`
    done
    echo ${EnergyF[@]} >> ../force_en.temp
#
#
  echo " " >> ../force_en.temp
done

return 0

}

calc_numforce
if [[ $? -ne 0 ]];then
   echo "ERROR: Failure in numerical force calculation."
   exit 1
fi

#
#
cd ..
#
#   Fortran part
./fNumForce > numforce.dat
if [[ $? -ne 0 ]];then
   echo "ERROR: Failure in numerical force calculation."
   exit 1
fi
###########################################################

# Now check, whether we have data from previous time step
if [ ! -e orb_tdc1.temp ] || [ ! -e ci_tdc1.temp ]; then
   echo "No data from previous step."
   echo "Setting TDC to zero and exiting."
   mv orb_tdc2.temp orb_tdc1.temp
   mv ci_tdc2.temp ci_tdc1.temp
   mv csf_tdc2.temp csf_tdc1.temp
   mv strTDC_2.str strTDC_1.str
   echo "0th time step: TDC set to 0." >  tdcoups.dat
   echo "0th time step: TDC set to 0." >>  tdcoups.dat
   for ((i=1;i<=$ForceState;i++)){
      echo -n "$i " >> tdcoups.dat
      for ((j=1;j<=$ForceState;j++)){
      echo -n " 0.00000000 " >> tdcoups.dat
      }
      echo "" >> tdcoups.dat
   }
   exit 0
fi

#
# FINALLY, calculate overlap and TDC

#  now the Overlap calculation 
if [ -d OVERLAP ]; then
  rm -r OVERLAP
  mkdir OVERLAP
else
  mkdir OVERLAP
fi
cd OVERLAP
echo ' $CONTRL SCFTYP=RHF COORD=UNIQUE
  RUNTYP=ENERGY' > overlap.inp
echo "  NOSYM=1 ICHARG=$(( $CHARGE * 2 ))
  MULT=$MULT NPRINT=3 ISPHER=1
 \$END
 \$SYSTEM MWORDS=50 \$END" >> overlap.inp
echo "$BAZE" >> overlap.inp
echo ' $DATA
 overlap (t,t+h)
 C1' >> overlap.inp
../GAMConvStr ../$STRFILE1 | tail -n $NAtom >> overlap.inp
../GAMConvStr ../$STRFILE2 | tail -n $NAtom >> overlap.inp
echo ' $END
  ' >> overlap.inp
#
#   now is the time to run overlap.inp
$runoverlap overlap.inp > overlap.out 2>err.over.tmp
# extract overlap matrix
NLineS1=`grep -n "OVERLAP MATRIX" overlap.out | head -n 1 | awk -F":" '{print $1}'`
NLineS2=`grep -n "BARE NUCLEUS HAMILTONIAN INTEGRALS" overlap.out | awk -F":" '{print $1}'`
NDiffLine=$(( $NLineS2 - $NLineS1 - 1 ))
grep -w " OVERLAP MATRIX" overlap.out -A$NDiffLine > ../over_tdc.temp 
cd ..
#
#   Running the FORTRAN part (asymmetric formula)
./fTDCoups > asym_tdcoups.dat
#
#   Running the FORTRAN part (symmetric formula, if there are data from previous run)
if [ -e before_asym_tdcoups.dat ]; then
  ./fTDCoups_sym > tdcoups.dat
else
  cp asym_tdcoups.dat tdcoups.dat
fi
#
#

# Cleaning up and copying
rm -r OVERLAP over_tdc.temp
# rm orb_tdc* ci_tdc*
mv orb_tdc2.temp orb_tdc1.temp
mv ci_tdc2.temp ci_tdc1.temp
mv csf_tdc2.temp csf_tdc1.temp
mv strTDC_2.str strTDC_1.str
cp asym_tdcoups.dat before_asym_tdcoups.dat


